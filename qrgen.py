import PIL
import PIL.Image
import random
import urllib
import cStringIO

def encode(data):
	data = cStringIO.StringIO(urllib.urlopen("http://chart.apis.google.com/chart?chs=200x200&cht=qr&chl=%s" % str(data)).read())
	
	image = PIL.Image.open(data)
#	image.save("fetched.png")
	
	## This function is a little hacky.  To extract the module bitmap from the qr code generated by google
	## we need to crop off the outer blank area AND calculate the size of each module in pixels. To 
	## calculate the crop area we look for the first black pixel in the image and count the number of 
	## black pixels in a row.  The coordinate of the first black pixel tells us what we can crop off the
	## image AND the size of the first run of black pixels (which is 7 modules wide - as per standard) can
	## tell us the module size.
	##
	## http://en.wikipedia.org/wiki/QR_Code (see Overview)
	
	def find_code(image):
		for y in range(0, image.size[1]):
			for x in range(0, image.size[0]):
				data = image.getpixel((x, y))
				if data[0] == 0:
					len = 0
					i = x
					
					while data[0] == 0:
						i = i + 1
						len = len + 1
						data = image.getpixel((i, y))
						
					return x, y, len / 7
	
	left, top, module_size = find_code(image)
	
	image = image.crop((left, top, image.size[0] - left, image.size[1] - top))
	image = image.resize((image.size[0] / module_size, image.size[1] / module_size))
#	image.save("small.png")
	
	return image
	
def decorate(modules_tiles, code):
	# we take the module size (in pixels) for our output image based upon the largest input image. Note
	# you will get the best results if all images are the same size
	widths = [image.size[0] for image in modules_tiles]
	heights = [image.size[1] for image in modules_tiles]
		
	max_width = max(widths)
	max_height = max(heights)
	
	# note that the image is slightly larger, the convention is to leave a 4 module boundary around
	# the image without noise - it makes it easier to read.
	out = PIL.Image.new("RGBA", (max_width*(code.size[0]+8), max_height*(code.size[1]+8)), (255,255,255,255))
	
	def is_light(val):
		return val[0] > 127 and val[1] > 127 and val[2] > 127
	
	for x in range(0, code.size[0]):
		for y in range(0, code.size[1]):
				if not is_light(code.getpixel((x, y))):
					gem = random.choice(modules_tiles)
					out.paste(gem, ((x+4)*max_width, (y+4)*max_height), gem)

	return out

if __name__ == "__main__":
	from optparse import OptionParser
	
	parser = OptionParser()
	parser.add_option("-i", "--image", dest="images", help="FILES to use in the QR code", metavar="FILES", action="append")
	parser.add_option("-d", "--data", dest="data", help="Data to encode in qr code", action="store")
	parser.add_option("-o", "--output", dest="output", help="FILE to write generated qr code into", action="store")
	parser.add_option("-s", "--scale", dest="scale", type="int", help="Percent the scale the resulting image by", action="store")

	(options, args) = parser.parse_args()
	
	if options.images is None:
		parser.error("You need to specify at least one image")

	if options.data is None:
		parser.error("You need to the data to encode")

	if options.output is None:
		parser.error("You need to specify the output file")

	tiles = [PIL.Image.open(x) for x in options.images]
	
	img = decorate(tiles, encode(options.data))
	
	if options.scale is not None:
		img = img.resize((int(img.size[0] * (options.scale / 100.0)), int(img.size[1] * (options.scale / 100.0))), PIL.Image.ANTIALIAS)
	
	img.save(options.output)




